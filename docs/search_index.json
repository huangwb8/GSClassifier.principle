[["index.html", "The Principle of R Package GSClassifier Welcome License Other Projects", " The Principle of R Package GSClassifier Weibin Huang 2022-09-15 Welcome The Priciple of GSClassifier is a book for GSClassifier users who want to know the most details. If you’re looking for the PDF edition, you can find it at here. License This work, as a whole, is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. The code contained in this book is simultaneously available under the MIT license; this means that you are free to use it in your own packages, as long as you cite the source. Other Projects You may also be interested in: “GSClassifier” A comprehensive classification tool based on pure transcriptomics for precision medicine. “luckyModel” Model ensemble for third-party lucky series, such GSClassifier. "],["the-principle-of-gsclassifier.html", "Chapter 1 The Principle of GSClassifier 1.1 Introduction 1.2 Flowchart 1.3 Simulated Dataset 1.4 Missing values 1.5 Top scoring pairs (TSP)", " Chapter 1 The Principle of GSClassifier 1.1 Introduction GSClassifier is an R package for modeling and identification of gene expression profiles (GEPs) subtypes. The detail of usage had been demonstrated in Github WiKi. Here, we propose to introduce the principle of GSClassifier, including flowchart, top scoring pairs (TSP) algorithm, and batch effect control. 1.2 Flowchart The flowchart of GSClassifier is showed in Figure 1.1. 1.2.1 Data Processing For each dataset, RNA expression matrix would be normalized internally (Raw Matrix) so that the expression data of the samples in the dataset were comparable and suitable for subtype identification. As demonstrated in Figure 1.1, the Subtype vector is identified based on independent cohorts instead of a merged matrix with batch effect control technologies. More details about batch effect control are discussed in 2.3. There is no standard method to figure out subtype vectors. It depends on the Gene Expression Profiles (GEPs) used, the biological problems or ideas of researchers. For Pan-immune Activation and Dysfunction (PAD) subtypes, the GEPs, Pan-Immune Activation Module (PIAM) and Pan-Immune Dysfunction Genes (PIDG), are biologically associated and suitable for calling four sutbypes (PIAMhighPIDGhigh, PIAMhighPIDGlow, PIAMlowPIDGhigh, and PIAMlowPIDGlow). Theoretically, we can also use a category strategy like low/medium/high, but more evidences or motivations are lacked for chasing such a complex model. With subtype vectors and raw matrices, Top Scoring Pairs (TSP), the core data format for model training and application in GSClassifier, would be calculated for the following process. The details of TSP are summarized in 1.5. 1.2.2 Model Establishment and Validation How to training 1.2.3 Model Application How to use Figure 1.1: The flow chart of GSClassifier 1.3 Simulated Dataset First, load needed packages: # Install &quot;devtools&quot; package if (!requireNamespace(&quot;devtools&quot;, quietly = TRUE)) install.packages(&quot;devtools&quot;) # Install dependencies if (!requireNamespace(&quot;luckyBase&quot;, quietly = TRUE)) devtools::install_github(&quot;huangwb8/luckyBase&quot;) # Install the &quot;GSClassifier&quot; package if (!requireNamespace(&quot;GSClassifier&quot;, quietly = TRUE)) devtools::install_github(&quot;huangwb8/GSClassifier&quot;) # Install the &quot;pacman&quot; package if (!requireNamespace(&quot;pacman&quot;, quietly = TRUE)){ install.packages(&quot;pacman&quot;) library(pacman) } else { library(pacman) } # Load needed packages packages_needed &lt;- c( &quot;readxl&quot;, &quot;ComplexHeatmap&quot;, &quot;GSClassifier&quot;, &quot;rpart&quot;, &quot;tidyr&quot;) for(i in packages_needed){p_load(char=i)} We simulated a dataset: # Geneset geneSet &lt;- list( Set1 = paste(&#39;Gene&#39;,1:3,sep = &#39;&#39;), Set2 = paste(&#39;Gene&#39;,4:6,sep = &#39;&#39;) ) # RNA expression x &lt;- read_xlsx(&#39;./data/simulated-data.xlsx&#39;, sheet = &#39;RNA&#39;) expr0 &lt;- as.matrix(x[,-1]) rownames(expr0) &lt;- as.character(as.matrix(x[,1])); rm(x) # Subtype information # It depends on the application scenarios of GEPs subtype_vector &lt;- c(1, 1, 1, 2, 2, 2) # Binned data for subtype 1 Ybin &lt;- ifelse(subtype_vector == 1, 1, 0) # Parameters breakVec = c(0, 0.25, 0.5, 0.75, 1.0) # Report cat(c(&#39;\\n&#39;, &#39;Gene sets:&#39;, &#39;\\n&#39;)) print(geneSet) cat(&#39;RNA expression:&#39;, &#39;\\n&#39;) print(expr0) # # Gene sets: # $Set1 # [1] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; # # $Set2 # [1] &quot;Gene4&quot; &quot;Gene5&quot; &quot;Gene6&quot; # # RNA expression: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 0.51 0.52 0.60 0.21 0.30 0.40 # Gene2 0.52 0.54 0.58 0.22 0.31 0.35 # Gene3 0.53 0.60 0.61 NA 0.29 0.30 # Gene4 0.21 0.30 0.40 0.51 0.52 0.60 # Gene5 0.22 0.31 0.35 0.52 0.54 0.58 # Gene6 0.23 0.29 0.30 0.53 NA 0.61 # Gene7 0.10 0.12 0.09 0.11 0.12 0.14 Look at the matrix via heatmap: Heatmap(t(scale(t(expr0))), name = &quot;Z-score&quot;) This is an intersting dataset with features as following: Distinguished gene sets: The expression profile between Gene 1-3 and Gene 4-6 is obviously different arross samples. Thus, these gene sets might represent different biology meaning. Stable gene: The expression level and rank of Gene 7 seemed to be similar across samples. Thus, Gene 7 might not be a robust marker for subtype modeling. Thus, it could help us to understand how filtering of GSClassifier works. Expression heterogeneity &amp; rank homogeneity: Take Sample1 and Sample3 as examples. The expression of Gene 1-6 in Sample3 seemed to be higher than those of Sample1. However, the expression of Gene 1-3 is higher than Gene 4-6 in both Sample1 and Sample3, indicating similar bioprocess in these samples exists so that they should be classified as the same subtype. 1.4 Missing values Here, we fill missing value with Recursive Partitioning and Regression Trees (RPART) algorithm: # RPART expr &lt;- GSClassifier:::na_fill(expr0, method=&quot;anova&quot;, na.action = na.rpart) # Report cat(&#39;RNA expression:&#39;, &#39;\\n&#39;) print(expr0) cat(&#39;\\n&#39;) cat(&#39;RNA expression without NA value:&#39;, &#39;\\n&#39;) print(expr) # RNA expression: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 0.51 0.52 0.60 0.21 0.30 0.40 # Gene2 0.52 0.54 0.58 0.22 0.31 0.35 # Gene3 0.53 0.60 0.61 NA 0.29 0.30 # Gene4 0.21 0.30 0.40 0.51 0.52 0.60 # Gene5 0.22 0.31 0.35 0.52 0.54 0.58 # Gene6 0.23 0.29 0.30 0.53 NA 0.61 # Gene7 0.10 0.12 0.09 0.11 0.12 0.14 # # RNA expression without NA value: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 0.51 0.52 0.60 0.210 0.300 0.40 # Gene2 0.52 0.54 0.58 0.220 0.310 0.35 # Gene3 0.53 0.60 0.61 0.466 0.290 0.30 # Gene4 0.21 0.30 0.40 0.510 0.520 0.60 # Gene5 0.22 0.31 0.35 0.520 0.540 0.58 # Gene6 0.23 0.29 0.30 0.530 0.392 0.61 # Gene7 0.10 0.12 0.09 0.110 0.120 0.14 Look at the new matrix via heatmap, where the clustering result is not obviously disturbed by NA filling: Heatmap(t(scale(t(expr))), name = &quot;Z-score&quot;) Although RPART algorithm is proved to be powerful dealing with NA value, we should try to use markers with less NA as possible. During PAD subtype establishment, only genes occurring in over 80% of datasets were retained so as to minumize the impact from mising value. 1.5 Top scoring pairs (TSP) With subtype vectors and Raw Matrix, the TSP matrix for a specified subtypes could be calculated via function GSClassifier::trainDataProc: trainDataProc( Xmat, Yvec, geneSet, subtype = 1, # 0.2 was Used in PAD project ptail = 0.2, # c(0, 0.25, 0.5, 0.75, 1.0) was Used in PAD project breakVec = c(0, 0.25, 0.5, 0.75, 1.0) ) As show in Figure 1.2, The TSP matrix consists of 3 parts: binned expression, pair difference, and set difference. Next, we would use a simulated dataset to introduce how TSP matrix calculated in GSClassifier. Figure 1.2: The components of TSP (2 gene sets) 1.5.1 Binned expression First, we binned genes with diffrent quantile intervals so that the distribution of rank information could be more consistent across samples. Take Sample4 as an example: # Data of Sample4 x &lt;- expr[,4] # Create quantiles brks &lt;- quantile(as.numeric(x), probs=breakVec, na.rm = T) # Get interval orders xbin &lt;- .bincode(x = x, breaks = brks, include.lowest = T) xbin &lt;- as.numeric(xbin) names(xbin) &lt;- names(x) # Report cat(&#39;Quantiles:&#39;, &#39;\\n&#39;); print(brks) cat(&#39;\\n&#39;) cat(&#39;Raw expression:&#39;, &#39;\\n&#39;);print(x) cat(&#39;\\n&#39;) cat(&#39;Binned expression:&#39;, &#39;\\n&#39;); print(xbin) # Quantiles: # 0% 25% 50% 75% 100% # 0.110 0.215 0.466 0.515 0.530 # # Raw expression: # Gene1 Gene2 Gene3 Gene4 Gene5 Gene6 Gene7 # 0.210 0.220 0.466 0.510 0.520 0.530 0.110 # # Binned expression: # Gene1 Gene2 Gene3 Gene4 Gene5 Gene6 Gene7 # 1 2 2 3 4 4 1 For example, 0.110 is the minimun of the raw expression vector, so its binned expression is 1. Similarly, the binned expression of maximum 0.530 is 4. Generally, we calculate binned expression via function breakBin of GSClassifier: expr_binned &lt;- apply( expr, 2, GSClassifier:::breakBin, breakVec) rownames(expr_binned) &lt;- rownames(expr) print(expr_binned) # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 3 3 4 1 2 2 # Gene2 4 4 3 2 2 2 # Gene3 4 4 4 2 1 1 # Gene4 1 2 2 3 4 4 # Gene5 2 2 2 4 4 3 # Gene6 2 1 1 4 3 4 # Gene7 1 1 1 1 1 1 In this simulated dataset, Gene7 is a gene whose expression is always the lowest across all samples. In other words, the rank of Gene7 is stable or invariable across samples so that it’s not robust for identification of differentail subtypes. Except binned expression, we also calculated pair difference later. Due to the number of gene pair is \\(C_{2 \\atop n}\\), the removement of genes like Gene7 before modeling could really reduce the complexibility and save computing resources. In all, genes with low rank difference should be dropped out in some extent in GSClassifier. First, We use base::rank to return the sample ranks of the values in a vector: expr_binned_rank &lt;- apply( expr_binned, 2, function(x)rank(x, na.last = TRUE) ) print(expr_binned_rank) # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 5.0 5.0 6.5 1.5 3.5 3.5 # Gene2 6.5 6.5 5.0 3.5 3.5 3.5 # Gene3 6.5 6.5 6.5 3.5 1.5 1.5 # Gene4 1.5 3.5 3.5 5.0 6.5 6.5 # Gene5 3.5 3.5 3.5 6.5 6.5 5.0 # Gene6 3.5 1.5 1.5 6.5 5.0 6.5 # Gene7 1.5 1.5 1.5 1.5 1.5 1.5 Then, get weighted average rank difference of each gene based on specified subtype distribution (Ybin): testRes &lt;- sapply( 1:nrow(expr_binned_rank), function(gi){ # Rank vector of each gene rankg = expr_binned_rank[gi,]; # Weighted average rank difference of a gene for specified subtype # Here is subtype 1 vs. others (sum(rankg[Ybin == 0], na.rm = T) / sum(Ybin == 0, na.rm = T)) - (sum(rankg[Ybin == 1], na.rm = T) / sum(Ybin == 1, na.rm = T)) } ) names(testRes) &lt;- rownames(expr_binned_rank) print(testRes) # Gene1 Gene2 Gene3 Gene4 Gene5 Gene6 Gene7 # -2.666667 -2.500000 -4.333333 3.166667 2.500000 3.833333 0.000000 Gene7 is the one with the lowest absolute value (0) of rank diffrence. By the way, Gene 1-3 have the same direction (&lt;0), so do Gene 4-6 (&gt;0), which indicates the nature of clustering based on these two gene sets. In practice, we use ptail to select differential genes based on rank diffrences. Smaller ptail is, less gene kept. Here, we just set ptail=0.4: # ptail is a numeber ranging (0,0.5]. ptail = 0.4 # Index of target genes with big rank differences idx &lt;- which((testRes &lt; quantile(testRes, ptail, na.rm = T)) | (testRes &gt; quantile(testRes, 1.0-ptail, na.rm = T))) # Target genes gene_bigRank &lt;- names(testRes)[idx] # Report cat(&#39;Index of target genes: &#39;,&#39;\\n&#39;);print(idx); cat(&#39;\\n&#39;) cat(&#39;Target genes:&#39;,&#39;\\n&#39;);print(gene_bigRank) # Index of target genes: # Gene1 Gene2 Gene3 Gene4 Gene5 Gene6 # 1 2 3 4 5 6 # # Target genes: # [1] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; &quot;Gene4&quot; &quot;Gene5&quot; &quot;Gene6&quot; Hence, Gene7 was filtered and excluded in the following analysis. By the way, both ptail and breakVec are hyperparameters in GSClassifier modeling. 1.5.2 Pair difference In GSClassifier, we use a ensemble function featureSelection to select data for pair difference scoring. expr_feat &lt;- featureSelection(expr, Ybin, testRes = testRes, ptail = 0.4) expr_sub &lt;- expr_feat$Xsub gene_bigRank &lt;- expr_feat$Genes # Report cat(&#39;Raw xpression without NA:&#39;, &#39;\\n&#39;) print(expr_sub) cat(&#39;\\n&#39;) cat(&#39;Genes with large rank diff:&#39;, &#39;\\n&#39;) print(gene_bigRank) # Raw xpression without NA: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 0.51 0.52 0.60 0.210 0.300 0.40 # Gene2 0.52 0.54 0.58 0.220 0.310 0.35 # Gene3 0.53 0.60 0.61 0.466 0.290 0.30 # Gene4 0.21 0.30 0.40 0.510 0.520 0.60 # Gene5 0.22 0.31 0.35 0.520 0.540 0.58 # Gene6 0.23 0.29 0.30 0.530 0.392 0.61 # # Genes with large rank diff: # [1] &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; &quot;Gene4&quot; &quot;Gene5&quot; &quot;Gene6&quot; In GSClassifier, we use function makeGenePairs to calculate s gene_bigRank_pairs &lt;- GSClassifier:::makeGenePairs( gene_bigRank, expr[gene_bigRank,]) print(gene_bigRank_pairs) # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1:Gene2 0 0 1 0 0 1 # Gene1:Gene3 0 0 0 0 1 1 # Gene1:Gene4 1 1 1 0 0 0 # Gene1:Gene5 1 1 1 0 0 0 # Gene1:Gene6 1 1 1 0 0 0 # Gene2:Gene3 0 0 0 0 1 1 # Gene2:Gene4 1 1 1 0 0 0 # Gene2:Gene5 1 1 1 0 0 0 # Gene2:Gene6 1 1 1 0 0 0 # Gene3:Gene4 1 1 1 0 0 0 # Gene3:Gene5 1 1 1 0 0 0 # Gene3:Gene6 1 1 1 0 0 0 # Gene4:Gene5 0 0 1 0 0 1 # Gene4:Gene6 0 1 1 0 1 0 # Gene5:Gene6 0 1 1 0 1 0 Take Gene1:Gene4 of Sample1 as an example. \\(Expression_{Gene1} - Expression_{Gene4} = 0.51-0.21 = 0.3 &gt; 0\\), so the pair score is 1. If the difference is less than or equal to 0, the pair score is 0. In addition, the difference of gene pair scoring between Sample 1-3 and Sample 4-6 is obivous, revealing the robustness of pair difference for subtype identification. 1.5.3 Set difference In GSClassifier, Set difference is defined as a weight average of gene-geneset rank difference. # No. of gene sets nGS = 2 # Name of gene set comparision, which is like s1s2, s1s3 and so on. featureNames &lt;- &#39;s1s2&#39; # Gene set difference across samples resultList &lt;- list() for (i in 1:ncol(expr_sub)) { # i=1 res0 &lt;- numeric(length=length(featureNames)) idx &lt;- 1 for (j1 in 1:(nGS-1)) { # j1=1 for (j2 in (j1+1):nGS) { # j2=2 # If j1=1 and j2=2, gene sets s1/s2 would be selected # Genes of different gene sets set1 &lt;- geneSet[[j1]] # &quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; set2 &lt;- geneSet[[j2]] # &quot;Gene4&quot; &quot;Gene5&quot; &quot;Gene6&quot; # RNA expression of Genes by different gene sets vals1 &lt;- expr_sub[rownames(expr_sub) %in% set1,i] # Gene1 Gene2 Gene3 # 0.51 0.52 0.53 vals2 &lt;- expr_sub[rownames(expr_sub) %in% set2,i] # Gene4 Gene5 Gene6 # 0.21 0.22 0.23 # Differences between one gene and gene sets # Compare expression of each gene in Set1 with all genes in Set2. # For example, 0.51&gt;0.21/0.22/0.23, so the value of Gene1:s2 is 3. res1 &lt;- sapply(vals1, function(v1) sum(v1 &gt; vals2, na.rm=T)) # Gene1:s2 Gene2:s2 Gene3:s2 # 3 3 3 # Weight average of gene-geneset rank difference res0[idx] &lt;- sum(res1, na.rm = T) / (length(vals1) * length(vals2)) # Next gene set pair idx &lt;- idx + 1 } } resultList[[i]] &lt;- as.numeric(res0) } resMat &lt;- do.call(cbind, resultList) colnames(resMat) &lt;- colnames(expr_sub) rownames(resMat) &lt;- featureNames # Report cat(&#39;Set difference across samples: &#39;, &#39;\\n&#39;) print(resMat) # Set difference across samples: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # s1s2 1 1 1 0 0 0 In GSClassifier, we established makeSetData to evaluate set difference across samples: # Gene set difference across samples geneset_interaction &lt;- GSClassifier:::makeSetData(expr_sub, geneSet) # Report cat(&#39;Set difference across samples: &#39;, &#39;\\n&#39;) print(resMat) # Set difference across samples: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # s1s2 1 1 1 0 0 0 We have known that the subtype of Sample 1-3 differs from that of Sample 4-6, which revealed the robustness of set difference for subtype indentification. As shown in Figure 1.2, TSP matrix here should be : # TSP matrix tsp &lt;- rbind( # Binned expression expr_binned[gene_bigRank,], # Pair difference gene_bigRank_pairs, # Set difference resMat ) # Report cat(&#39;TSP matrix: &#39;, &#39;\\n&#39;) print(tsp) # TSP matrix: # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 # Gene1 3 3 4 1 2 2 # Gene2 4 4 3 2 2 2 # Gene3 4 4 4 2 1 1 # Gene4 1 2 2 3 4 4 # Gene5 2 2 2 4 4 3 # Gene6 2 1 1 4 3 4 # Gene1:Gene2 0 0 1 0 0 1 # Gene1:Gene3 0 0 0 0 1 1 # Gene1:Gene4 1 1 1 0 0 0 # Gene1:Gene5 1 1 1 0 0 0 # Gene1:Gene6 1 1 1 0 0 0 # Gene2:Gene3 0 0 0 0 1 1 # Gene2:Gene4 1 1 1 0 0 0 # Gene2:Gene5 1 1 1 0 0 0 # Gene2:Gene6 1 1 1 0 0 0 # Gene3:Gene4 1 1 1 0 0 0 # Gene3:Gene5 1 1 1 0 0 0 # Gene3:Gene6 1 1 1 0 0 0 # Gene4:Gene5 0 0 1 0 0 1 # Gene4:Gene6 0 1 1 0 1 0 # Gene5:Gene6 0 1 1 0 1 0 # s1s2 1 1 1 0 0 0 "],["discussion.html", "Chapter 2 Discussion 2.1 Model complexibility 2.2 Missing value 2.3 Subtype vector calling", " Chapter 2 Discussion 2.1 Model complexibility Linear growth/exponential growth 2.2 Missing value Talk about strategy in subtypes modeling and calling 2.3 Subtype vector calling "],["references.html", "References", " References "]]
